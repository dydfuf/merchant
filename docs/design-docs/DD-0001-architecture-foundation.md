# Design Doc: DD-0001 Architecture Foundation

## 1. 배경

스플렌더는 턴제 보드게임이지만 멀티플레이 환경에서는 동시성, 치팅 방지, 재접속 복구가 핵심 요구사항이다.
초기 구현에서 구조를 잘못 잡으면 룰 복제, 상태 불일치, 운영 비용 급증이 빠르게 발생한다.

## 2. 문제 정의

다음을 동시에 만족하는 아키텍처가 필요하다.

- 실시간 반응성
- 서버 권위 룰 판정
- Firestore 기반 빠른 구독
- 에이전트/사람 공통으로 유지 가능한 경계

## 3. 목표

- Command/Event/State 분리
- 결정론적 룰 엔진
- 명시적인 레이어/도메인 경계
- Turborepo 패키지 단위 책임 고정

## 4. 비목표

- 초기 단계에서 완전한 대규모 매칭 시스템 구축
- 모든 운영 자동화의 즉시 도입
- 분산 트랜잭션 최적화

## 5. 대안 비교

### 대안 A: Firestore 중심 클라이언트 직접 쓰기

장점:

- 개발 속도 빠름
- 구현 단순

단점:

- 치팅 방지 어려움
- 동시성 충돌 처리 취약
- 클라이언트별 룰 구현 편차 발생

### 대안 B: Firestore + Cloud Functions(Command 처리)

장점:

- 서버 권위 확보 가능
- 인프라 운영 부담 상대적으로 낮음

단점:

- 함수 콜드스타트/관측성 제한 가능성
- 복잡한 세션 라우팅은 별도 고려 필요

### 대안 C: Realtime Gateway + Application Service + Firestore

장점:

- 실시간 제어/관측성 우수
- 멱등/버전/권한 정책 구현 용이
- 확장 시 토폴로지 명확

단점:

- 초기 구성 복잡도 증가
- 서비스 운영 요소 증가

## 6. 최종 선택

대안 C를 기준 아키텍처로 채택한다.
단, 구현은 단계적으로 진행하며 MVP에서는 Firestore 중심 기능을 우선 확보한다.

채택 이유:

- 게임 룰의 무결성과 운영 확장성을 동시에 확보하기 쉬움
- 관심사 분리 규칙을 코드 레벨로 강제하기 쉬움
- 에이전트 기반 개발에서 파일/패키지 책임이 명확해짐

## 7. 세부 설계

- 클라이언트: Command 전송 + Read Model 구독
- 서버: 인증, 멱등성, 버전 검증, 룰 적용
- 룰 엔진: 순수 함수, seed 기반 결정론
- 저장소: Event append + Snapshot 갱신

핵심 스키마:

- `games/{gameId}`
- `games/{gameId}/commands/{commandId}`
- `games/{gameId}/events/{eventId}`

## 8. 리스크 및 완화

- 리스크: 서버/Firestore 경계 중복
- 완화: infra adapter와 application service 역할 문서화 + lint 규칙

- 리스크: 룰 엔진 외부 의존 유입
- 완화: `rule-engine` import 제한 규칙 적용

- 리스크: 버전 충돌 처리 UX 저하
- 완화: 충돌 응답 표준화 + 클라이언트 재시도 가이드

## 9. 성공 지표

- 룰 판정 경로가 클라이언트 코드에 중복되지 않음
- command idempotency 오류 0건
- 충돌 처리 케이스 테스트 커버 확보

## 10. 결정 필요 항목

- 인증 공급자(Firebase Auth 고정 여부)
- `apps/game-server` 런타임(Cloud Run vs 대체)
- 관전/리플레이 데이터 보존 기간
